# 链表（上）：如何实现LRU缓存淘汰算法?
1. C语言中指针占用几个字节

   指针即为地址，指针几个字节跟语言无关，而是跟系统的寻址能力有关。现在一般是32位系统，所以是4个字节，64为的系统，就是8个字节。可以通过如下的代码来查看运行环境中指针占多大字节。

   ``` C++
   #include <stdio.h>   
   int main(void)  
   {  
       int a=1;  
       char b='a';  
       float c=1.0;  
       void *p;  
       p=&a;  
       printf("a的地址为：0x%x，其字节数为：%d\n",p,sizeof(p));  
       p=&b;  
       printf("b的地址为：0x%x，其字节数为：%d\n",p,sizeof(p));  
       p=&c;  
       printf("c的地址为：0x%x，其字节数为：%d\n",p,sizeof(p));  
       return 0;  
   } 
   ```

   参考如下的网上资源：

   > https://blog.csdn.net/IOSSHAN/article/details/88944637
   >
   > https://blog.csdn.net/koches/article/details/7627381#

2. 单链表中尾结点的后继指针问题

   在单链表中，尾结点的后继指针next指向的不再是下一个结点。而是指向一个空地址null。这样做的好处在于：防止尾结点的后继指针next成为一个野指针，导致遍历链表根本停不下来，或者出现一些本不属于该链表的垃圾数据。

3. 参考《大话数据结构》中的内容，对于头结点，头指针的区别和联系。

   参考URL：http://data.biancheng.net/view/103.html

   头结点：是放在第一个元素结点之前的一个节点，其数据域一般无意义(也可以存放链表的长度)。头结点可有可无。

   头指针：如果存在头节点，那么头指针则是指向头结点的指针。如果不存在头节点，那么头指针则是执行第一个结点元素的指针。头指针是链表必须存在的。

   

   ![image-20201010143937238](https://ftp.bmp.ovh/imgs/2020/10/d13c4b566ebd570b.jpg)

4. 单链表实现LRU，数组实现LRU

   单链表LRU：我们约定，越靠近链表尾部的结点是越早之前访问的(当然也可以是链尾是越后访问的)。当有一个新的数据被访问的时候，我们从链表头开始顺序遍历链表。

   * 如果此数据之前已经被缓存在链表中了，我们遍历得到这个数据对应的结点，并将其从原来的位置删除，然后再插入到链表的头部；
   * 如果此数据没有在缓存链表中，可以分为两种情况：如果此时缓存未满，则将此结点直接插入到链表的头部；
   * 如果此时缓存已满，则链表尾结点删除，将新的数据结点插入链表的头部。

   数组LRU：同样我们约定，越靠近数组尾部的元素是越迟访问的。当有一个新的数据被访问的时候，我们就从数组的第一个元素开始顺序遍历数组。

   * 如果此数据之前已经被缓存在数组中了，我们遍历得到这个数据对应的元素的位置，并将其从原来的位置删除，然后再插入到数组的尾部。
   * 如果此数据没有在缓存的数组中，可以分为两种情况：如果此时缓存未满，则将此元素直接插入到数组的末尾；
   * 如果此时缓存已满，则将数组的第一个元素删除，将新的元素插入到数组的尾部。

5. 判断一个字符串是否是回文字符串，这个字符串是通过单链表来存储的。

   ```
   使用快慢两个指针找到链表中点，
   慢指针每次前进一步，快指针每次前进两步。
   在慢指针前进的过程中，同时修改其next指针，
   使得链表前半部分反序。
   最后比较中点两侧的链表是否相等。
   时间复杂度：O(n)
   ```

   
